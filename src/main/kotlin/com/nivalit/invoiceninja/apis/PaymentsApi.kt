/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package com.nivalit.invoiceninja.apis

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import com.nivalit.invoiceninja.models.AuthenticationError
import com.nivalit.invoiceninja.models.AuthorizationError
import com.nivalit.invoiceninja.models.Error
import com.nivalit.invoiceninja.models.Payment
import com.nivalit.invoiceninja.models.ValidationError

import com.squareup.moshi.Json

import com.nivalit.invoiceninja.infrastructure.ApiClient
import com.nivalit.invoiceninja.infrastructure.ApiResponse
import com.nivalit.invoiceninja.infrastructure.ClientException
import com.nivalit.invoiceninja.infrastructure.ClientError
import com.nivalit.invoiceninja.infrastructure.ServerException
import com.nivalit.invoiceninja.infrastructure.ServerError
import com.nivalit.invoiceninja.infrastructure.MultiValueMap
import com.nivalit.invoiceninja.infrastructure.PartConfig
import com.nivalit.invoiceninja.infrastructure.RequestConfig
import com.nivalit.invoiceninja.infrastructure.RequestMethod
import com.nivalit.invoiceninja.infrastructure.ResponseType
import com.nivalit.invoiceninja.infrastructure.Success
import com.nivalit.invoiceninja.infrastructure.toMultiValue

class PaymentsApi(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://demo.invoiceninja.com")
        }
    }

    /**
     * Custom payment actions
     * Performs a custom action on an Payment.      The current range of actions are as follows     - clone_to_Payment     - clone_to_quote     - history     - delivery_note     - mark_paid     - download     - archive     - delete     - email
     * @param X_API_TOKEN The API token to be used for authentication
     * @param xRequestedWith Used to send the XMLHttpRequest header
     * @param id The Payment Hashed ID
     * @param action The action string to be performed
     * @param include Includes child relationships in the response, format is comma separated. Check each model for the list of associated includes (optional)
     * @return Payment
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    @Deprecated(message = "This operation is deprecated.")
    fun actionPayment(X_API_TOKEN: kotlin.String, xRequestedWith: kotlin.String, id: kotlin.String, action: kotlin.String, include: kotlin.String? = null) : Payment {
        @Suppress("DEPRECATION")
        val localVarResponse = actionPaymentWithHttpInfo(X_API_TOKEN = X_API_TOKEN, xRequestedWith = xRequestedWith, id = id, action = action, include = include)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Payment
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Custom payment actions
     * Performs a custom action on an Payment.      The current range of actions are as follows     - clone_to_Payment     - clone_to_quote     - history     - delivery_note     - mark_paid     - download     - archive     - delete     - email
     * @param X_API_TOKEN The API token to be used for authentication
     * @param xRequestedWith Used to send the XMLHttpRequest header
     * @param id The Payment Hashed ID
     * @param action The action string to be performed
     * @param include Includes child relationships in the response, format is comma separated. Check each model for the list of associated includes (optional)
     * @return ApiResponse<Payment?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    @Deprecated(message = "This operation is deprecated.")
    fun actionPaymentWithHttpInfo(X_API_TOKEN: kotlin.String, xRequestedWith: kotlin.String, id: kotlin.String, action: kotlin.String, include: kotlin.String?) : ApiResponse<Payment?> {
        @Suppress("DEPRECATION")
        val localVariableConfig = actionPaymentRequestConfig(X_API_TOKEN = X_API_TOKEN, xRequestedWith = xRequestedWith, id = id, action = action, include = include)

        return request<Unit, Payment>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation actionPayment
     *
     * @param X_API_TOKEN The API token to be used for authentication
     * @param xRequestedWith Used to send the XMLHttpRequest header
     * @param id The Payment Hashed ID
     * @param action The action string to be performed
     * @param include Includes child relationships in the response, format is comma separated. Check each model for the list of associated includes (optional)
     * @return RequestConfig
     */
    @Deprecated(message = "This operation is deprecated.")
    fun actionPaymentRequestConfig(X_API_TOKEN: kotlin.String, xRequestedWith: kotlin.String, id: kotlin.String, action: kotlin.String, include: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (include != null) {
                    put("include", listOf(include.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        X_API_TOKEN.apply { localVariableHeaders["X-API-TOKEN"] = this.toString() }
        xRequestedWith.apply { localVariableHeaders["X-Requested-With"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v1/payments/{id}/{action}".replace("{"+"id"+"}", encodeURIComponent(id.toString())).replace("{"+"action"+"}", encodeURIComponent(action.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Bulk payment actions
     * 
     * @param X_API_TOKEN The API token to be used for authentication
     * @param xRequestedWith Used to send the XMLHttpRequest header
     * @param requestBody User credentials
     * @param index Replaces the default response index from data to a user specific string (optional)
     * @return Payment
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun bulkPayments(X_API_TOKEN: kotlin.String, xRequestedWith: kotlin.String, requestBody: kotlin.collections.List<kotlin.Int>, index: kotlin.String? = null) : Payment {
        val localVarResponse = bulkPaymentsWithHttpInfo(X_API_TOKEN = X_API_TOKEN, xRequestedWith = xRequestedWith, requestBody = requestBody, index = index)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Payment
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Bulk payment actions
     * 
     * @param X_API_TOKEN The API token to be used for authentication
     * @param xRequestedWith Used to send the XMLHttpRequest header
     * @param requestBody User credentials
     * @param index Replaces the default response index from data to a user specific string (optional)
     * @return ApiResponse<Payment?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun bulkPaymentsWithHttpInfo(X_API_TOKEN: kotlin.String, xRequestedWith: kotlin.String, requestBody: kotlin.collections.List<kotlin.Int>, index: kotlin.String?) : ApiResponse<Payment?> {
        val localVariableConfig = bulkPaymentsRequestConfig(X_API_TOKEN = X_API_TOKEN, xRequestedWith = xRequestedWith, requestBody = requestBody, index = index)

        return request<kotlin.collections.List<kotlin.Int>, Payment>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation bulkPayments
     *
     * @param X_API_TOKEN The API token to be used for authentication
     * @param xRequestedWith Used to send the XMLHttpRequest header
     * @param requestBody User credentials
     * @param index Replaces the default response index from data to a user specific string (optional)
     * @return RequestConfig
     */
    fun bulkPaymentsRequestConfig(X_API_TOKEN: kotlin.String, xRequestedWith: kotlin.String, requestBody: kotlin.collections.List<kotlin.Int>, index: kotlin.String?) : RequestConfig<kotlin.collections.List<kotlin.Int>> {
        val localVariableBody = requestBody
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (index != null) {
                    put("index", listOf(index.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        X_API_TOKEN.apply { localVariableHeaders["X-API-TOKEN"] = this.toString() }
        xRequestedWith.apply { localVariableHeaders["X-Requested-With"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v1/payments/bulk",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Delete payment
     * Handles the deletion of an Payment by id
     * @param X_API_TOKEN The API token to be used for authentication
     * @param xRequestedWith Used to send the XMLHttpRequest header
     * @param id The Payment Hashed ID
     * @param include Includes child relationships in the response, format is comma separated. Check each model for the list of associated includes (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deletePayment(X_API_TOKEN: kotlin.String, xRequestedWith: kotlin.String, id: kotlin.String, include: kotlin.String? = null) : Unit {
        val localVarResponse = deletePaymentWithHttpInfo(X_API_TOKEN = X_API_TOKEN, xRequestedWith = xRequestedWith, id = id, include = include)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Delete payment
     * Handles the deletion of an Payment by id
     * @param X_API_TOKEN The API token to be used for authentication
     * @param xRequestedWith Used to send the XMLHttpRequest header
     * @param id The Payment Hashed ID
     * @param include Includes child relationships in the response, format is comma separated. Check each model for the list of associated includes (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun deletePaymentWithHttpInfo(X_API_TOKEN: kotlin.String, xRequestedWith: kotlin.String, id: kotlin.String, include: kotlin.String?) : ApiResponse<Unit?> {
        val localVariableConfig = deletePaymentRequestConfig(X_API_TOKEN = X_API_TOKEN, xRequestedWith = xRequestedWith, id = id, include = include)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deletePayment
     *
     * @param X_API_TOKEN The API token to be used for authentication
     * @param xRequestedWith Used to send the XMLHttpRequest header
     * @param id The Payment Hashed ID
     * @param include Includes child relationships in the response, format is comma separated. Check each model for the list of associated includes (optional)
     * @return RequestConfig
     */
    fun deletePaymentRequestConfig(X_API_TOKEN: kotlin.String, xRequestedWith: kotlin.String, id: kotlin.String, include: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (include != null) {
                    put("include", listOf(include.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        X_API_TOKEN.apply { localVariableHeaders["X-API-TOKEN"] = this.toString() }
        xRequestedWith.apply { localVariableHeaders["X-Requested-With"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/v1/payments/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Edit payment
     * Displays an Payment by id
     * @param X_API_TOKEN The API token to be used for authentication
     * @param xRequestedWith Used to send the XMLHttpRequest header
     * @param id The Payment Hashed ID
     * @param include Includes child relationships in the response, format is comma separated. Check each model for the list of associated includes (optional)
     * @return Payment
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun editPayment(X_API_TOKEN: kotlin.String, xRequestedWith: kotlin.String, id: kotlin.String, include: kotlin.String? = null) : Payment {
        val localVarResponse = editPaymentWithHttpInfo(X_API_TOKEN = X_API_TOKEN, xRequestedWith = xRequestedWith, id = id, include = include)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Payment
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Edit payment
     * Displays an Payment by id
     * @param X_API_TOKEN The API token to be used for authentication
     * @param xRequestedWith Used to send the XMLHttpRequest header
     * @param id The Payment Hashed ID
     * @param include Includes child relationships in the response, format is comma separated. Check each model for the list of associated includes (optional)
     * @return ApiResponse<Payment?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun editPaymentWithHttpInfo(X_API_TOKEN: kotlin.String, xRequestedWith: kotlin.String, id: kotlin.String, include: kotlin.String?) : ApiResponse<Payment?> {
        val localVariableConfig = editPaymentRequestConfig(X_API_TOKEN = X_API_TOKEN, xRequestedWith = xRequestedWith, id = id, include = include)

        return request<Unit, Payment>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation editPayment
     *
     * @param X_API_TOKEN The API token to be used for authentication
     * @param xRequestedWith Used to send the XMLHttpRequest header
     * @param id The Payment Hashed ID
     * @param include Includes child relationships in the response, format is comma separated. Check each model for the list of associated includes (optional)
     * @return RequestConfig
     */
    fun editPaymentRequestConfig(X_API_TOKEN: kotlin.String, xRequestedWith: kotlin.String, id: kotlin.String, include: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (include != null) {
                    put("include", listOf(include.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        X_API_TOKEN.apply { localVariableHeaders["X-API-TOKEN"] = this.toString() }
        xRequestedWith.apply { localVariableHeaders["X-Requested-With"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v1/payments/{id}/edit".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * List payments
     * Lists payments, search and filters allow fine grained lists to be generated.          Query parameters can be added to performed more fine grained filtering of the payments, these are handled by the PaymentFilters class which defines the methods available
     * @param X_API_TOKEN The API token to be used for authentication
     * @param xRequestedWith Used to send the XMLHttpRequest header
     * @param include Includes child relationships in the response, format is comma separated. Check each model for the list of associated includes (optional)
     * @param status Filter the entity based on their status. ie active / archived / deleted. Format is a comma separated string with any of the following options:   - active - archived - deleted  (optional)
     * @param clientId Filters the entity list by client_id. Suitable when you only want the entities of a specific client.  (optional)
     * @param createdAt Filters the entity list by the created at timestamp. Parameter value can be a datetime string or unix timestamp  (optional)
     * @param updatedAt Filters the entity list by the updated at timestamp. Parameter value can be a datetime string or unix timestamp  (optional)
     * @param isDeleted Filters the entity list by entities that have been deleted.  (optional)
     * @param filterDeletedClients Filters the entity list and only returns entities for clients that have not been deleted  (optional)
     * @param vendorId Filters the entity list by an associated vendor  (optional)
     * @param filter Searches across a range of columns including:   - amount   - date   - custom_value1   - custom_value2   - custom_value3   - custom_value4  (optional)
     * @param number Search payments by payment number  (optional)
     * @param sort Returns the list sorted by column in ascending or descending order. (optional)
     * @return Payment
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getPayments(X_API_TOKEN: kotlin.String, xRequestedWith: kotlin.String, include: kotlin.String? = null, status: kotlin.String? = null, clientId: kotlin.String? = null, createdAt: kotlin.Int? = null, updatedAt: kotlin.Int? = null, isDeleted: kotlin.Boolean? = null, filterDeletedClients: kotlin.String? = null, vendorId: kotlin.String? = null, filter: kotlin.String? = null, number: kotlin.String? = null, sort: kotlin.String? = null) : Payment {
        val localVarResponse = getPaymentsWithHttpInfo(X_API_TOKEN = X_API_TOKEN, xRequestedWith = xRequestedWith, include = include, status = status, clientId = clientId, createdAt = createdAt, updatedAt = updatedAt, isDeleted = isDeleted, filterDeletedClients = filterDeletedClients, vendorId = vendorId, filter = filter, number = number, sort = sort)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Payment
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * List payments
     * Lists payments, search and filters allow fine grained lists to be generated.          Query parameters can be added to performed more fine grained filtering of the payments, these are handled by the PaymentFilters class which defines the methods available
     * @param X_API_TOKEN The API token to be used for authentication
     * @param xRequestedWith Used to send the XMLHttpRequest header
     * @param include Includes child relationships in the response, format is comma separated. Check each model for the list of associated includes (optional)
     * @param status Filter the entity based on their status. ie active / archived / deleted. Format is a comma separated string with any of the following options:   - active - archived - deleted  (optional)
     * @param clientId Filters the entity list by client_id. Suitable when you only want the entities of a specific client.  (optional)
     * @param createdAt Filters the entity list by the created at timestamp. Parameter value can be a datetime string or unix timestamp  (optional)
     * @param updatedAt Filters the entity list by the updated at timestamp. Parameter value can be a datetime string or unix timestamp  (optional)
     * @param isDeleted Filters the entity list by entities that have been deleted.  (optional)
     * @param filterDeletedClients Filters the entity list and only returns entities for clients that have not been deleted  (optional)
     * @param vendorId Filters the entity list by an associated vendor  (optional)
     * @param filter Searches across a range of columns including:   - amount   - date   - custom_value1   - custom_value2   - custom_value3   - custom_value4  (optional)
     * @param number Search payments by payment number  (optional)
     * @param sort Returns the list sorted by column in ascending or descending order. (optional)
     * @return ApiResponse<Payment?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getPaymentsWithHttpInfo(X_API_TOKEN: kotlin.String, xRequestedWith: kotlin.String, include: kotlin.String?, status: kotlin.String?, clientId: kotlin.String?, createdAt: kotlin.Int?, updatedAt: kotlin.Int?, isDeleted: kotlin.Boolean?, filterDeletedClients: kotlin.String?, vendorId: kotlin.String?, filter: kotlin.String?, number: kotlin.String?, sort: kotlin.String?) : ApiResponse<Payment?> {
        val localVariableConfig = getPaymentsRequestConfig(X_API_TOKEN = X_API_TOKEN, xRequestedWith = xRequestedWith, include = include, status = status, clientId = clientId, createdAt = createdAt, updatedAt = updatedAt, isDeleted = isDeleted, filterDeletedClients = filterDeletedClients, vendorId = vendorId, filter = filter, number = number, sort = sort)

        return request<Unit, Payment>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getPayments
     *
     * @param X_API_TOKEN The API token to be used for authentication
     * @param xRequestedWith Used to send the XMLHttpRequest header
     * @param include Includes child relationships in the response, format is comma separated. Check each model for the list of associated includes (optional)
     * @param status Filter the entity based on their status. ie active / archived / deleted. Format is a comma separated string with any of the following options:   - active - archived - deleted  (optional)
     * @param clientId Filters the entity list by client_id. Suitable when you only want the entities of a specific client.  (optional)
     * @param createdAt Filters the entity list by the created at timestamp. Parameter value can be a datetime string or unix timestamp  (optional)
     * @param updatedAt Filters the entity list by the updated at timestamp. Parameter value can be a datetime string or unix timestamp  (optional)
     * @param isDeleted Filters the entity list by entities that have been deleted.  (optional)
     * @param filterDeletedClients Filters the entity list and only returns entities for clients that have not been deleted  (optional)
     * @param vendorId Filters the entity list by an associated vendor  (optional)
     * @param filter Searches across a range of columns including:   - amount   - date   - custom_value1   - custom_value2   - custom_value3   - custom_value4  (optional)
     * @param number Search payments by payment number  (optional)
     * @param sort Returns the list sorted by column in ascending or descending order. (optional)
     * @return RequestConfig
     */
    fun getPaymentsRequestConfig(X_API_TOKEN: kotlin.String, xRequestedWith: kotlin.String, include: kotlin.String?, status: kotlin.String?, clientId: kotlin.String?, createdAt: kotlin.Int?, updatedAt: kotlin.Int?, isDeleted: kotlin.Boolean?, filterDeletedClients: kotlin.String?, vendorId: kotlin.String?, filter: kotlin.String?, number: kotlin.String?, sort: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (include != null) {
                    put("include", listOf(include.toString()))
                }
                if (status != null) {
                    put("status", listOf(status.toString()))
                }
                if (clientId != null) {
                    put("client_id", listOf(clientId.toString()))
                }
                if (createdAt != null) {
                    put("created_at", listOf(createdAt.toString()))
                }
                if (updatedAt != null) {
                    put("updated_at", listOf(updatedAt.toString()))
                }
                if (isDeleted != null) {
                    put("is_deleted", listOf(isDeleted.toString()))
                }
                if (filterDeletedClients != null) {
                    put("filter_deleted_clients", listOf(filterDeletedClients.toString()))
                }
                if (vendorId != null) {
                    put("vendor_id", listOf(vendorId.toString()))
                }
                if (filter != null) {
                    put("filter", listOf(filter.toString()))
                }
                if (number != null) {
                    put("number", listOf(number.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        X_API_TOKEN.apply { localVariableHeaders["X-API-TOKEN"] = this.toString() }
        xRequestedWith.apply { localVariableHeaders["X-Requested-With"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v1/payments",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Blank payment
     * Returns a blank object with default values
     * @param X_API_TOKEN The API token to be used for authentication
     * @param xRequestedWith Used to send the XMLHttpRequest header
     * @param include Includes child relationships in the response, format is comma separated. Check each model for the list of associated includes (optional)
     * @return Payment
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getPaymentsCreate(X_API_TOKEN: kotlin.String, xRequestedWith: kotlin.String, include: kotlin.String? = null) : Payment {
        val localVarResponse = getPaymentsCreateWithHttpInfo(X_API_TOKEN = X_API_TOKEN, xRequestedWith = xRequestedWith, include = include)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Payment
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Blank payment
     * Returns a blank object with default values
     * @param X_API_TOKEN The API token to be used for authentication
     * @param xRequestedWith Used to send the XMLHttpRequest header
     * @param include Includes child relationships in the response, format is comma separated. Check each model for the list of associated includes (optional)
     * @return ApiResponse<Payment?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getPaymentsCreateWithHttpInfo(X_API_TOKEN: kotlin.String, xRequestedWith: kotlin.String, include: kotlin.String?) : ApiResponse<Payment?> {
        val localVariableConfig = getPaymentsCreateRequestConfig(X_API_TOKEN = X_API_TOKEN, xRequestedWith = xRequestedWith, include = include)

        return request<Unit, Payment>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getPaymentsCreate
     *
     * @param X_API_TOKEN The API token to be used for authentication
     * @param xRequestedWith Used to send the XMLHttpRequest header
     * @param include Includes child relationships in the response, format is comma separated. Check each model for the list of associated includes (optional)
     * @return RequestConfig
     */
    fun getPaymentsCreateRequestConfig(X_API_TOKEN: kotlin.String, xRequestedWith: kotlin.String, include: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (include != null) {
                    put("include", listOf(include.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        X_API_TOKEN.apply { localVariableHeaders["X-API-TOKEN"] = this.toString() }
        xRequestedWith.apply { localVariableHeaders["X-Requested-With"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v1/payments/create",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Show payment
     * Displays an Payment by id
     * @param X_API_TOKEN The API token to be used for authentication
     * @param xRequestedWith Used to send the XMLHttpRequest header
     * @param id The Payment Hashed ID
     * @param include Includes child relationships in the response, format is comma separated. Check each model for the list of associated includes (optional)
     * @return Payment
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun showPayment(X_API_TOKEN: kotlin.String, xRequestedWith: kotlin.String, id: kotlin.String, include: kotlin.String? = null) : Payment {
        val localVarResponse = showPaymentWithHttpInfo(X_API_TOKEN = X_API_TOKEN, xRequestedWith = xRequestedWith, id = id, include = include)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Payment
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Show payment
     * Displays an Payment by id
     * @param X_API_TOKEN The API token to be used for authentication
     * @param xRequestedWith Used to send the XMLHttpRequest header
     * @param id The Payment Hashed ID
     * @param include Includes child relationships in the response, format is comma separated. Check each model for the list of associated includes (optional)
     * @return ApiResponse<Payment?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun showPaymentWithHttpInfo(X_API_TOKEN: kotlin.String, xRequestedWith: kotlin.String, id: kotlin.String, include: kotlin.String?) : ApiResponse<Payment?> {
        val localVariableConfig = showPaymentRequestConfig(X_API_TOKEN = X_API_TOKEN, xRequestedWith = xRequestedWith, id = id, include = include)

        return request<Unit, Payment>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation showPayment
     *
     * @param X_API_TOKEN The API token to be used for authentication
     * @param xRequestedWith Used to send the XMLHttpRequest header
     * @param id The Payment Hashed ID
     * @param include Includes child relationships in the response, format is comma separated. Check each model for the list of associated includes (optional)
     * @return RequestConfig
     */
    fun showPaymentRequestConfig(X_API_TOKEN: kotlin.String, xRequestedWith: kotlin.String, id: kotlin.String, include: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (include != null) {
                    put("include", listOf(include.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        X_API_TOKEN.apply { localVariableHeaders["X-API-TOKEN"] = this.toString() }
        xRequestedWith.apply { localVariableHeaders["X-Requested-With"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v1/payments/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Create payment
     * Adds an Payment to the system
     * @param X_API_TOKEN The API token to be used for authentication
     * @param xRequestedWith Used to send the XMLHttpRequest header
     * @param payment The payment request
     * @param include Includes child relationships in the response, format is comma separated. Check each model for the list of associated includes (optional)
     * @return Payment
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun storePayment(X_API_TOKEN: kotlin.String, xRequestedWith: kotlin.String, payment: Payment, include: kotlin.String? = null) : Payment {
        val localVarResponse = storePaymentWithHttpInfo(X_API_TOKEN = X_API_TOKEN, xRequestedWith = xRequestedWith, payment = payment, include = include)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Payment
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Create payment
     * Adds an Payment to the system
     * @param X_API_TOKEN The API token to be used for authentication
     * @param xRequestedWith Used to send the XMLHttpRequest header
     * @param payment The payment request
     * @param include Includes child relationships in the response, format is comma separated. Check each model for the list of associated includes (optional)
     * @return ApiResponse<Payment?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun storePaymentWithHttpInfo(X_API_TOKEN: kotlin.String, xRequestedWith: kotlin.String, payment: Payment, include: kotlin.String?) : ApiResponse<Payment?> {
        val localVariableConfig = storePaymentRequestConfig(X_API_TOKEN = X_API_TOKEN, xRequestedWith = xRequestedWith, payment = payment, include = include)

        return request<Payment, Payment>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation storePayment
     *
     * @param X_API_TOKEN The API token to be used for authentication
     * @param xRequestedWith Used to send the XMLHttpRequest header
     * @param payment The payment request
     * @param include Includes child relationships in the response, format is comma separated. Check each model for the list of associated includes (optional)
     * @return RequestConfig
     */
    fun storePaymentRequestConfig(X_API_TOKEN: kotlin.String, xRequestedWith: kotlin.String, payment: Payment, include: kotlin.String?) : RequestConfig<Payment> {
        val localVariableBody = payment
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (include != null) {
                    put("include", listOf(include.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        X_API_TOKEN.apply { localVariableHeaders["X-API-TOKEN"] = this.toString() }
        xRequestedWith.apply { localVariableHeaders["X-Requested-With"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v1/payments",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Refund payment
     * Adds an Refund to the system
     * @param X_API_TOKEN The API token to be used for authentication
     * @param xRequestedWith Used to send the XMLHttpRequest header
     * @param payment The refund request
     * @param include Includes child relationships in the response, format is comma separated. Check each model for the list of associated includes (optional)
     * @return Payment
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun storeRefund(X_API_TOKEN: kotlin.String, xRequestedWith: kotlin.String, payment: Payment, include: kotlin.String? = null) : Payment {
        val localVarResponse = storeRefundWithHttpInfo(X_API_TOKEN = X_API_TOKEN, xRequestedWith = xRequestedWith, payment = payment, include = include)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Payment
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Refund payment
     * Adds an Refund to the system
     * @param X_API_TOKEN The API token to be used for authentication
     * @param xRequestedWith Used to send the XMLHttpRequest header
     * @param payment The refund request
     * @param include Includes child relationships in the response, format is comma separated. Check each model for the list of associated includes (optional)
     * @return ApiResponse<Payment?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun storeRefundWithHttpInfo(X_API_TOKEN: kotlin.String, xRequestedWith: kotlin.String, payment: Payment, include: kotlin.String?) : ApiResponse<Payment?> {
        val localVariableConfig = storeRefundRequestConfig(X_API_TOKEN = X_API_TOKEN, xRequestedWith = xRequestedWith, payment = payment, include = include)

        return request<Payment, Payment>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation storeRefund
     *
     * @param X_API_TOKEN The API token to be used for authentication
     * @param xRequestedWith Used to send the XMLHttpRequest header
     * @param payment The refund request
     * @param include Includes child relationships in the response, format is comma separated. Check each model for the list of associated includes (optional)
     * @return RequestConfig
     */
    fun storeRefundRequestConfig(X_API_TOKEN: kotlin.String, xRequestedWith: kotlin.String, payment: Payment, include: kotlin.String?) : RequestConfig<Payment> {
        val localVariableBody = payment
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (include != null) {
                    put("include", listOf(include.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        X_API_TOKEN.apply { localVariableHeaders["X-API-TOKEN"] = this.toString() }
        xRequestedWith.apply { localVariableHeaders["X-Requested-With"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v1/payments/refund",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Update payment
     * Handles the updating of an Payment by id
     * @param X_API_TOKEN The API token to be used for authentication
     * @param xRequestedWith Used to send the XMLHttpRequest header
     * @param id The Payment Hashed ID
     * @param include Includes child relationships in the response, format is comma separated. Check each model for the list of associated includes (optional)
     * @return Payment
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun updatePayment(X_API_TOKEN: kotlin.String, xRequestedWith: kotlin.String, id: kotlin.String, include: kotlin.String? = null) : Payment {
        val localVarResponse = updatePaymentWithHttpInfo(X_API_TOKEN = X_API_TOKEN, xRequestedWith = xRequestedWith, id = id, include = include)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Payment
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Update payment
     * Handles the updating of an Payment by id
     * @param X_API_TOKEN The API token to be used for authentication
     * @param xRequestedWith Used to send the XMLHttpRequest header
     * @param id The Payment Hashed ID
     * @param include Includes child relationships in the response, format is comma separated. Check each model for the list of associated includes (optional)
     * @return ApiResponse<Payment?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun updatePaymentWithHttpInfo(X_API_TOKEN: kotlin.String, xRequestedWith: kotlin.String, id: kotlin.String, include: kotlin.String?) : ApiResponse<Payment?> {
        val localVariableConfig = updatePaymentRequestConfig(X_API_TOKEN = X_API_TOKEN, xRequestedWith = xRequestedWith, id = id, include = include)

        return request<Unit, Payment>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation updatePayment
     *
     * @param X_API_TOKEN The API token to be used for authentication
     * @param xRequestedWith Used to send the XMLHttpRequest header
     * @param id The Payment Hashed ID
     * @param include Includes child relationships in the response, format is comma separated. Check each model for the list of associated includes (optional)
     * @return RequestConfig
     */
    fun updatePaymentRequestConfig(X_API_TOKEN: kotlin.String, xRequestedWith: kotlin.String, id: kotlin.String, include: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (include != null) {
                    put("include", listOf(include.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        X_API_TOKEN.apply { localVariableHeaders["X-API-TOKEN"] = this.toString() }
        xRequestedWith.apply { localVariableHeaders["X-Requested-With"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/api/v1/payments/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Upload a payment document
     * Handles the uploading of a document to a payment
     * @param X_API_TOKEN The API token to be used for authentication
     * @param xRequestedWith Used to send the XMLHttpRequest header
     * @param id The Payment Hashed ID
     * @param include Includes child relationships in the response, format is comma separated. Check each model for the list of associated includes (optional)
     * @return Payment
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun uploadPayment(X_API_TOKEN: kotlin.String, xRequestedWith: kotlin.String, id: kotlin.String, include: kotlin.String? = null) : Payment {
        val localVarResponse = uploadPaymentWithHttpInfo(X_API_TOKEN = X_API_TOKEN, xRequestedWith = xRequestedWith, id = id, include = include)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Payment
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Upload a payment document
     * Handles the uploading of a document to a payment
     * @param X_API_TOKEN The API token to be used for authentication
     * @param xRequestedWith Used to send the XMLHttpRequest header
     * @param id The Payment Hashed ID
     * @param include Includes child relationships in the response, format is comma separated. Check each model for the list of associated includes (optional)
     * @return ApiResponse<Payment?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun uploadPaymentWithHttpInfo(X_API_TOKEN: kotlin.String, xRequestedWith: kotlin.String, id: kotlin.String, include: kotlin.String?) : ApiResponse<Payment?> {
        val localVariableConfig = uploadPaymentRequestConfig(X_API_TOKEN = X_API_TOKEN, xRequestedWith = xRequestedWith, id = id, include = include)

        return request<Unit, Payment>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation uploadPayment
     *
     * @param X_API_TOKEN The API token to be used for authentication
     * @param xRequestedWith Used to send the XMLHttpRequest header
     * @param id The Payment Hashed ID
     * @param include Includes child relationships in the response, format is comma separated. Check each model for the list of associated includes (optional)
     * @return RequestConfig
     */
    fun uploadPaymentRequestConfig(X_API_TOKEN: kotlin.String, xRequestedWith: kotlin.String, id: kotlin.String, include: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (include != null) {
                    put("include", listOf(include.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        X_API_TOKEN.apply { localVariableHeaders["X-API-TOKEN"] = this.toString() }
        xRequestedWith.apply { localVariableHeaders["X-Requested-With"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/api/v1/payments/{id}/upload".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
